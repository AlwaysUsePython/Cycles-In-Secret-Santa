# -*- coding: utf-8 -*-
"""Average Cycles In Secret Santa Problem

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mxQaVURSwjKMLAbr4dBjAOlXNm4LTY0v

**This program aims to simulate a secret santa gift exchange where no person can get themself and the pairings are randomly chosen. Using a simulation, I hope to answer the question of what the average largest cycle is in a secret santa group of n people.**

First, we obviusly need a way to make a random set of pairings. This function takes in a list of participants and returns a dictionary (or HashMap â€“ you pick what you call it) of the pairings.
"""

import random

def choosePairings(participants):

  # Initialize the final dictionary
  pairings = {}

  # Just like the problem on the stats test, the method for generating the pairings will be randomly choosing then restarting if someone draws themselves
  # The only difference is that this version draws the names one at a time and stops immediately if someone picks themselves
  successfullyChosen = False

  while not successfullyChosen:

    successfullyChosen = True

    # create a copy of the participants list
    available = []
    for member in participants:
      available.append(member)

    for person in participants:
      chosen = available[random.randint(0, len(available)-1)]

      if chosen == person:
        successfullyChosen = False
        break
      
      available.remove(chosen)
      pairings[person] = chosen
    
  return pairings

"""Now for a few tests to prove this is working..."""

mathOffice = choosePairings(["Mr. Weis", "Mr. Stout", "Mr. Chien", "Dr. Laffite", "Mr. Sim", "Mr. Palmer", "Mr. Theiss", "Dr. Helston", "Mr. Varney"])

numbers = []
for num in range(20):
  numbers.append(num)
numberVersion = choosePairings(numbers)


print("MATH OFFICE PAIRINGS:")
print()
for person in mathOffice:
  print(person, "->", mathOffice[person])
print()
print()
print("BORING NUMBER VERSION WITH 20 PEOPLE")
print()
for num in numberVersion:
  print(num, "->", numberVersion[num])

"""Now the hardest part: finding cycles.

There are two ways to do this. 

1) The way I initially thought of in class was to go through the pairings pair by pair and keep track of all the running incomplete cycles. This is definitely doable, however it's not as clean as I initially thought.

Say I have the cycle [0 -> 1, 1 -> 8] and also the cycle [9 -> 2, 2 -> 3] in my incomplete cycles list. Then I run into the pair [8 -> 9]. I now have to not only add it to the end of one cycle and the beginning of another, but also join the two cycles. Still very doable, but a bit messy and annoying. 

2) At this point, I realized there was a much simpler way to do it. The way we'd do it by hand is start at a number and follow it until its cycle is complete - every number is on *a* cycle... and then we move on to the next unused number's cycle. This should not only be much prettier but also a lot faster because there's a lot less calculation going on. If I'm picturing this right, it's even O(n), compared to method 1's O(n^2)
"""

def findCycles(pairings):

  cycles = []

  # make a list of people who we've already checked
  checked = []

  for person in pairings:

    # if they haven't already been accounted for...
    if person not in checked:

      # follow the cycle!
      completed = False

      cycle = []
      currentPerson = person

      while not completed:
        cycle.append(currentPerson)
        checked.append(currentPerson)
        currentPerson = pairings[currentPerson]

        # check to see if we looped back around
        if currentPerson == person:
          completed = True
        
        """
        DEBUG CODE / VERIFICATION THAT IT IS WORKING
        
        print(cycle)
        print(currentPerson)
        print(completed)
        ready = input()
        """

      cycles.append(cycle)
    
  return cycles

"""Now some tests for our cycle detection..."""

print(findCycles(mathOffice))
print(findCycles(numberVersion))

"""Now that this is working, all we need to do is run a simulation!"""

simulationNumber = 10000
numParticipants = 10

people = []
for i in range(numParticipants):
  people.append(i)

totalLength = 0

for simulation in range(simulationNumber):
  pairings = choosePairings(people)

  cycles = findCycles(pairings)

  maxLength = 0
  for cycle in cycles:
    length = len(cycle)
    if length > maxLength:
      maxLength = length
  
  totalLength += maxLength

  """
  DEBUG CODE/VERIFICATION THAT IT IS WORKING

  print("PAIRINGS")
  for person in pairings:
    print(person, "->", pairings[person])
  print()
  
  print(cycles)
  print(maxLength)
  ready = input("Enter to confirm")
  """
  

print(totalLength/simulationNumber)

"""Results:

In a group of 10 people, the average max cycle length is roughly 7

In a group of 50, it's roughly 32

In a group of 100, it's roughly 63

In a group of 200, it's roughly 125

So the conclusion is that the average largest cycle length in a group of n people roughly scales linearly!
"""